\section{Advanced component generators}
\label{sec:impl2}
In this section I introduce more advanced component generators for caching,
session management, load balancing, network communication and error handling.

\subsection{Storing data}
In order to implement behaviors such as caching or session management
components needs to be able to maintain an internal state.
To do this they need to store some information (this can be in memory, 
in a database etc.).
This section introduces an interface that specifies methods that an 
object must implement, in order to be used as a data storage. This 
separates the problem of managing the data storage from the logic of
the component that uses it.

\subsubsection{Storage Values}
Most of the components need to remove old values when they are no longer
valid or relevant. Hence, the package stores timestamped values. 
This values are represented by the struct type shown in Figure 
\ref{fig:StorageValue} below. There \texttt{Time} represents the time 
when the value becomes invalid and \texttt{Value} the value that is being
stored, which can be of any type.
\begin{figure}[h]
\centering
\begin{lstlisting}
type StorageValue struct {
  Value interface{}
  Time time.Time
}
\end{lstlisting}
\caption[scale=1.0]{Declaration of the \texttt{StorageValue} type.}
\label{fig:StorageValue}
\end{figure}

\subsubsection{Storage}
\texttt{Storage} is an interface representing thread safe mapping from string keys
to \texttt{StorageValues}. Its definition is shown in Figure \ref{fig:Storage} below.
\begin{figure}[h]
\centering
\begin{lstlisting}
type Storage interface {
  Get(string) (StorageValue, bool)
  Set(string, StorageValue)
  Remove(string)
  CompareAndRemove(string, StorageValue) bool
  Keys() []string
}
\end{lstlisting}
\caption[scale=1.0]{Declaration of the \texttt{Storage} interface.}
\label{fig:Storage}
\end{figure}
The package provides a default implementation of this interface that
stores the data in memory using (with minor modifications) sharded concurrent map implementation
by Or Hiltch\footnote{Code available at \url{https://github.com/orcaman/concurrent-map}}.
If a developer wants to store the values in the 
database instead, they can provide their own implementation of the 
\texttt{Store} interface
and use any component that uses the storage the same way as before.
This makes the components that use the storage highly configurable.

\subsubsection{Removing expired values}
In order to free up space used by expired values, the package implements
\texttt{StorageCleaner} function that does exactly that. Its type signature
is shown below:
\begin{lstlisting}
func StorageCleaner(storage Storage, shutDown <-chan bool, 
                    sleepTime time.Duration)
\end{lstlisting}
The function will repeatedly remove expired values from the provided
\texttt{storage} object until a message is sent on the \texttt{shutDown}
channel. After going through the whole storage object, the cleaner 
sleeps for time specified by the \texttt{sleepTime} argument.
Note that this can be used with any type of storage as it only accesses
the storage object via the methods specified by the \texttt{Storage} 
interface.

\subsection{Caching}
To support caching of outputs of components, the toolkit provides
component generator \texttt{CacheComponent}, which has the following type
signature:
\begin{lstlisting}
func CacheComponent(cache Storage, worker Component, 
            expiration time.Duration) Component
\end{lstlisting}
The returned component behaves as follows:
\begin{itemize}
  \item When a value is input that the component hasn't seen before, then
        the value is passed to the provided \texttt{worker} and the result 
        is stored in the provided \texttt{storage} object.

  \item When the component gets a previously seen value, it returns the value
        stored in the \texttt{storage} object, if it hasn't expired yet. If it 
        expired, then the component treats it as a new value.
\end{itemize}

For the generated component to function properly, the worker must output
a value for every value that is sent to it. This, however, is one of the 
conditions that any component must satisfy, so it shouldn't be an issue.

\subsection{Session Management}
This section introduces the component that supports management of any
type of session.
\subsubsection{States}
\label{sec:state}
To implement the logic of the session the toolkit uses \texttt{State}
interface, whose definition is shown in Figure \ref{fig:State}.
\begin{figure}[h]
\centering
\begin{lstlisting}
type State interface {
    Next(val Value) (State, error)
    Terminal() bool
    Result() Any
}
\end{lstlisting}
\caption[scale=1.0]{Declaration of the State interface.}
\label{fig:State}
\end{figure}
The expected behavior of the member functions is as follows:
\begin{itemize}
	\item The \texttt{Next} function returns the next state when provided 
        with a value or an error in case the next state can't be generated.
	\item The \texttt{Terminal} function indicates whether the current 
        state is a terminal state.
	\item The \texttt{Result} function returns the result that possibly 
        after further processing should be returned to the client.
\end{itemize}

\subsubsection{Session Manager}
\texttt{SessionManager} is a component generator that performs the 
management of sessions for individual users. It has the following signature:
\begin{lstlisting}
func SessionManager(store Storage, initial State, 
                seshExp time.Duration) Component
\end{lstlisting}
Its arguments are a \texttt{storage} object to be used, an \texttt{initial} 
state for each session and
a session expiration time.
The returned component behaves as a session manager. 
Its behavior is described below.

The component stores a mapping from session ids to the current state of the session
in the \texttt{storage} object.
Every new request gets assigned a unique session id. Then a current state
of the session is generated from the initial state using the provided
value. Afterwards a mapping from the generated id to the current state
is stored. The result of the call to the \texttt{Result} function on the
current state with the provided value is then sent down the pipeline and
response for the client is generated from it.

When a request with set `Session-Id' header comes in, the component gets the current 
state for the session and computes the next state for it based on the provided value.
The mapping is then updated with the new state and the result from the new state
is passed down the pipeline.

When a session reaches a terminal state, the session id is removed from the map
and the final result is outputted.
The states in the mapping are timestamped. Timestamps are updated every time
the state for a session is updated. When a client tries to access expired
session a new session for this client is started.

% More hype
The abstraction using states allows the users of the package to implement the
logic for the session, independently of the session management part.

\subsection{Dynamic Load Balancing}
To support load balancing based on the current traffic the toolkit implements
\texttt{DynamicLoadBalancer}. It is a component generator whose signature is
shown below. Its architecture is similar
to that of the \texttt{StaticLoadBalancer}.
\begin{lstlisting}
func DynamicLoadBalancer(addTimeout, removeTimeout time.Duration, 
        worker Component, maxWorkers int) Component
\end{lstlisting}
The returned component has an array of workers which can be easily shut down.
The initial number of workers is 1. 
For every input value, the generated component behaves as follows:
\begin{itemize}
	\item It tries to send the value to the workers, if this is not successful, 
		    before the \texttt{addTimeout}, then the component creates a new worker
        if the current number of workers is smaller than \texttt{maxWorkers}.
        Then the component tries to send the value to the workers again. This will 
        be successful in case a worker was added because then there is at least one 
        worker that is not busy.

	\item The workers send their results further down the pipeline.

	\item If there are no incoming values for duration equal to the 
        \texttt{removeTimeout}, then the component shuts down one 
        of the workers, if there is more than one worker.

	\item When the input channel of the component is closed, then the load balancer 
        shuts down all the workers and afterwards closes its output channel and
        terminates.
\end{itemize}
There are a lot of other possible load balancing strategies. 
Implementing them should be a simple modification of the existing code.
Note that this is very powerful concept as it can also be used to share
the load between multiple servers and turn them on or shut them down as
required (here using a different strategy might be preferred). There is
also a similar dynamic load balancer for writers.

\subsection{Error handling}

\subsubsection{Error Passer}
As a lot of components expect an input of a certain type, their execution
might end with an error if they are provided with an error result from
the previous component. This would make debugging very hard. Hence, the 
package provides the following component wrapper, that allows error messages
to bypass a component. The signature of this wrapper is shown below.
\begin{lstlisting}
func ErrorPasser(worker Component) Component
\end{lstlisting}
The inner design of the generated component is shown in Figure 
\ref{fig:errPasserDiag}. The behavior of the generated component 
can be described as follows:
\begin{itemize}
	\item For every input value it checks whether the result is an error
		  and if that is the cases it just outputs the value.
	\item If the result of the input value is not an error, then the component
		  passes the value to the worker, which after processing it passes 
		  it further down the pipeline.
\end{itemize}

\begin{figure}[h]
\centering
\begin{tikzpicture}[node distance = 2cm, auto]
    % Nodes
    \node[component, fill=gray!12, text width=1.5em] (passer) {};
    \node[component, right of=passer] (worker) {Worker};
    \node[above of=worker, node distance=1.5cm, xshift=-0.7cm](name){ErrorPasser};
    \node[text width=2em, right of=worker] (right) {};
    \node[below of=worker, node distance=1.2cm] (lineh) {};
    \node[left of=passer] (left) {};

    % Edges
    \path[line] (left) edge node {in} (passer); 
    \path (right.west) edge node {out} (right.east);
    \path[line] (right.west) -- (right.east);
    \path[line] (passer) -- (worker);
    \path[draw] (worker) -- (right);
    \path[draw] (passer.south) |- (lineh.east);
    \path[draw] (lineh.east) -| (right.west);
    \node[draw, densely dotted, inner sep=1em,
          fit=(passer) (worker) (lineh)] {};
\end{tikzpicture}
\caption[scale=1.0]{Inner design of the component generated with
  \texttt{ErrorPasser}.}
\label{fig:errPasserDiag}
\end{figure}

\subsubsection{Panic handling}
If we use a component which might cause panic, this will crash the whole
server when the panic occurs. Hence, the package provides the 
\texttt{PanicHandler}. The signature of this wrapper is shown 
below.
\begin{lstlisting}
func PanicHandler(worker Component) Component
\end{lstlisting}
It takes a component that can cause panic and returns a component the 
behaves as follows:
\begin{itemize}
	\item It passes every input value to the worker, gets the result 
        from it and then passes the result further down the pipeline.
	\item In case the worker crashes, that is it causes panic, the component 
        writes an error as a result for the value that caused the crash 
        and then restarts the worker.
	\item The component can itself cause a panic if the worker closes its 
        input channel, or if it closes its output channel before its input 
        channel is closed. That is if the worker violates the contract
        for components.
\end{itemize}

\subsection{Network Components}
In this section I present a component generator that can make network
requests. Then I introduce a helper component that alters incoming 
requests, so that they can be performed again using a different host
and a component that processes HTTP responses. Finally, I show how
can these components be plugged together to act as a proxy server. 

\subsubsection{Network Component}
Network Component is a component generator with the following signature:
\begin{lstlisting}
func NetworkComponent(client *http.Client) Component
\end{lstlisting}
It takes a single parameter, which is an http client.
The generated component for each input value makes an http request,
taken from the Result field of the value, using the provided http client.
If there is no request in the Result field or the request fails, then
the component returns an appropriate error. The behavior of the generated 
component is described in Figure \ref{fig:networkComp} below.

\begin{figure}[h]
\centering
\begin{tikzpicture}[node distance = 2cm, auto]
    % Nodes
    \node [component, densely dotted, ellipse] (internet) {Network};
    \node [component, text width=6em, below of=internet, node distance=3cm] (network) {Network Component};
    \node [left of=network, node distance = 3cm] (in) {};
    \node [right of=network, node distance = 3cm] (out) {};
    % Edges
    \path[line] (network) edge [bend right] (internet);
    \path[line] (internet) edge [bend right] (network);
    \path[line] (in) edge node {in} (network);
    \path[line] (network) edge node {out} (out);
\end{tikzpicture}
\caption[scale=1.0]{Design of the network component.}
\label{fig:networkComp}
\end{figure}

Note that the result of the request is fetched in the goroutine where the
component runs. Hence, slow requests might block the pipeline. To avoid
this behavior \texttt{NetworkComponent} is usually used together with one
of the load managers.

\subsubsection{Request Copier}
Request Copier is a component generator with the following signature:
\begin{lstlisting}
func RequestCopier(scheme, host string) Component
\end{lstlisting}
It takes string parameters scheme (e.g. http) and host (e.g. www.google.com) 
and returns a component that for each input value copies the Request made 
by the client to the Result field and updates it with the given scheme and 
path and then outputs this value.

\subsubsection{Response Processor}
The \texttt{Response} type of the \texttt{mpserver} package is defined as
a struct that is shown in Figure \ref{fig:Response}.
\begin{figure}[h]
\centering
\begin{lstlisting}
type Response struct {
		Header http.Header
		Body []byte
}
\end{lstlisting}
\caption[scale=1.0]{Declaration of type Response.}
\label{fig:Response}
\end{figure}

It holds the headers and body of an http response. The difference between
this definition and the definition in the default \texttt{http} package is that
the body of my \texttt{Response} is a slice of bytes. 
That is the body have already been
read and the connection to the server has been closed.

The \texttt{ResponseProcessor} is a component that for each input value
looks if the provided result is the default \texttt{http} Response. 
If that is the case,
then it reads the response and transfers it to \texttt{mpsever Response} 
type, which it
then writes to the result field and outputs the value. If no response
is provided, then the component outputs an appropriate error.

To use this component after the \texttt{NetworkComponent}, 
the \texttt{ResponseProcessor}
should be wrapped in an error passing component, so that when the\\
\texttt{NetworkComponent} fails, then the response processor won't have to do
any work.

\subsubsection{Proxy Component}
Proxy component is a combination of \texttt{RequestCopier}, 
\texttt{NetworkComponent} 
and \texttt{ResponseProcessor} in a linear pipeline. It acts as a proxy server
in the following sense. It forwards the provided request to the specified
host and then reads and outputs the response. 
All components are wrapped
in an \texttt{ErrorPasser} to avoid doing unnecessary work and to make the component
more robust. The implementation is shown in Figure \ref{fig:ProxyComp} below.

\begin{figure}[h]
\centering
\begin{lstlisting}
func ProxyComponent(scheme, host string, 
                    client *http.Client) Component {
  return LinkComponents(
    ErrorPasser(RequestCopier(scheme, host)),
    ErrorPasser(NetworkComponent(client)),
    ErrorPasser(ResponseProcessor))
}
\end{lstlisting}
\caption[scale=1.0]{Declaration of Proxy Component generator.}
\label{fig:ProxyComp}
\end{figure}
\subsection{Summary}
In this chapter I introduced more advanced component wrappers and generators
and described how to use them. The next chapter shows a few example
servers implemented using my toolkit.

