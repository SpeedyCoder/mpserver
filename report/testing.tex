\section{Performance Testing}
\label{sec:test}
In order to evaluate the performance of the \texttt{mpserver} toolkit we 
need to compare it against other server architectures.
This chapter presents the setup and results of the performance tests
that were carried on equivalent servers implemented in the \texttt{mpserver} toolkit,
in plain Go, in \texttt{webpipes} toolkit by James Whitehead II~\cite{whitehead} 
and the Apache framework.

\subsection{Setup}
To compare the performance of the four server architectures, I 
implemented a simple file server in all of them. Their performance 
was tested on serving a 4KB static file. The code for the servers 
that were implemented in Go is shown in Appendix~\ref{sec:testing.go}. To generate 
the load I used \texttt{httperf} tool~\cite{httperf}. To distribute 
the testing among multiple machines I used slightly modified version
of the \texttt{autohttperf} tool~\cite{whitehead}.
This setup is inspired by the one used in~\cite{whitehead}.

The server was run on a virtual machine with quad core processor and 
8GB of RAM. The machine was running CentOS Linux release 7.3.1611 (Core)
with Linux kernel 3.10.0.
I used 3 client machines with the same specification as the server machine, 
except that they had only 4GB of RAM. The version of Go on the machines was
1.6.3 linux/amd64. The version of Apache server used was 2.4.6 (CentOS).

The server machine had all the resources to itself. As the \texttt{httperf}
tool is single threaded, the client machines run up to 3 instances
of this command.

\subsection{Results}
The table in Figure~\ref{results} shows the results of the performance tests.
It shows the average response times in milliseconds for each server for
a given number of requests made per second. There are results for
three different versions of the servers implemented using the \texttt{mpserver}
toolkit. These versions are as follows:
\begin{itemize}
	\item \texttt{mpserver1} - uses as simple file server as 
		  described in Section~\ref{sec} without any load balancing

	\item \texttt{mpserver2} - uses static load balancing with 4 instances
		  of the simple file server writer

	\item \texttt{mpserver3} - uses dynamic load balancing with maximum number of 
		  workers set to 4
\end{itemize}

\begin{figure}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
Req/s & Go & webpipes & mpserver1 & mpserver2 & mpserver3 & Apache\\
\hline
100 & 0.42 & 0.55 & 0.45 & 0.45 & 0.55 & 1.75 \\
200 & 0.40 & 0.57 & 0.53 & 0.50 & 0.62 & 1.80 \\
300 & 0.50 & 0.60 & 0.50 & 0.50 & 0.62 & 1.70 \\
400 & 0.50 & 0.60 & 0.50 & 0.43 & 0.70 & 1.68 \\
500 & 0.45 & 0.50 & 0.43 & 0.53 & 0.72 & 1.85 \\
600 & 0.45 & 0.53 & 0.47 & 0.50 & 0.85 & 1.62 \\
700 & 0.47 & 0.62 & 0.43 & 0.40 & 1.02 & 1.62 \\
800 & 0.42 & 0.55 & 0.47 & 0.47 & 1.20 & 1.70 \\
\hline
\end{tabular}
\end{center}
\caption{Results table.}
% mpserver1= simple setup
% mpserver2= static load balancer
% mpserver3= dynamic load balancer
% mpserver4= listener load balancer
\label{results}
\end{figure}

Unexpectedly the Apache server gives the worst results. This is probably due to 
overheads for authorization that is not present on the other servers. As one would expect
the server implemented using plain Go gives the best results out of all the Go
implementations. 

Then second best are the implementations in the \texttt{mpserver}
toolkit, that use the simple file server and the file server with static load 
balancing. Their performance approximately the same as the file server is composed from 
4 parts (excluding the listener), so under a high load both implementations 
have 4 goroutines executing at the same time. The version with static load balancing
would be probably faster in case we were performing a more expensive operation than serving
a small static file. Then there could be 4 goroutines executing the expensive
operation, whereas in the simple case there would be only one goroutine 
executing this operation.

The \texttt{webpipes} toolkit performs slightly worse than the best two
\texttt{mpserver} implementations. As noted in Section~\ref{sec} this is probably
due to overhead for creating the readers-writers pairs.
The version using dynamic load balancing is the slowest one out of the Go implementations, 
this is most likely due to the fact that the load balancer is almost always ready to perform
an operation what occupies resources.

\subsection{Summary}
In this section I presented the setup and results of the performance tests performed.
The results for the \texttt{mpserver} toolkit are encouraging, as it is faster than
the \texttt{webpipes} toolkit and the difference between its performance and the performance
of the implementation in pure go is negligible. The next section summarizes the achievements 
of this project.