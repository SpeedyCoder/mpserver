\section{Building a shopping server}
\label{sec:shopping}
In this Chapter I show how to build a web-server using my toolkit that
maintains a shopping cart for a simple shopping web-site. The whole 
code for this example is shown in Appendix A.

\subsection{Shopping cart}
Shopping cart is represented by the struct type showed in Figure 
\ref{fig:shoppingCart} below.
\begin{figure}[h]
\begin{lstlisting}
type ShoppingCart struct {
    items map[string]int
    bought bool
}
\end{lstlisting}
\caption[scale=1.0]{Type representing a shopping cart.}
\label{fig:shoppingCart}
\end{figure}

Here, \texttt{items} is 
a mapping that represents the contents of the cart. It stores the names
of the items and their count. \texttt{bought} indicates whether the items
were purchased. In a real life scenario one might choose to use 
a list of ids rather than a map, but using a map keeps things simple
for the purposes of this example.

\subsection{Actions}
To represent actions that a user can take I used the interface show in 
Figure \ref{fig:action}.
\begin{figure}[h]
\begin{lstlisting}
type Action interface {
    performAction(s ShoppingCart) (mpserver.State, error)
}
\end{lstlisting}
\caption[scale=1.0]{Type representing an action that can be taken on 
a shopping cart.}
\label{fig:action}
\end{figure}
That is any action must implement the \texttt{performAction} method, which takes
a \texttt{ShoppingCart} object and tries to perform its operation on it. If
it succeeds then it returns the updated object and \texttt{nil} pointer for the
error. If it does not succeed then the method returns \texttt{nil} for the
object and the corresponding error.

The \texttt{Action} interface is implemented by the following 3 types
that represent adding items to the shopping cart, removing an item from it
and buying the contents of the shopping cart.
\begin{figure}[h]
\begin{lstlisting}
type AddAction struct {
    items []string
}
type RemoveAction struct {
    item string
}
type BuyAction struct {}
\end{lstlisting}
\caption[scale=1.0]{Types representing simple actions.}
\label{fig:actions}
\end{figure}

Now Figure \ref{fig:addAction} shows the implementation of the \texttt{performAction}
method for the \texttt{addAction}. This action creates the map object if 
necessary and then adds the contents of the items array in the \texttt{AddAction}
object to the items map in the \texttt{shoppingCart}.
\begin{figure}[h]
\begin{lstlisting}
func (a AddAction) performAction(s ShoppingCart) (State, error) {
    if (s.items == nil) {
        s.items = make(map[string]int)
    }
    for _, item := range a.items {
        s.items[item] += 1
    }
    return s, nil
}
\end{lstlisting}
\caption[scale=1.0]{\texttt{performAction} implementation for \texttt{addAction}.}
\label{fig:addAction}
\end{figure}

\subsection{Implementing State interface}
Now we want the \texttt{ShoppingCart} type to implement the \texttt{State} 
interface defined in section
\ref{sec:state}, so that it can be used by the session manager component.
This component will maintain one \texttt{ShoppingCart} object for each user.
Figure \ref{fig:shoppingCartImpl} below shows the implementation of the 
methods of the \texttt{State} interface for the \texttt{ShoppingCart} type.
\begin{figure}[h]
\begin{lstlisting}
func (s ShoppingCart) Next(val Value) (State, error) {
    a, ok := val.GetResult().(Action)
    if (!ok) {
        return nil, errors.New("No action provided")
    }

    return a.performAction(s)
}
func (s ShoppingCart) Result() interface{} {
    return s.items
}
func (s ShoppingCart) Terminal() bool {
    return s.bought
}
\end{lstlisting}
\caption[scale=1.0]{Implementation of the methods for \texttt{ShoppingCart}.}
\label{fig:shoppingCartImpl}
\end{figure}
These are all very simple methods. The \texttt{Next} method calls 
the \texttt{performAction} method on the provided action to generate 
the next state.

\subsection{Making actions}
Now we need a way to create actions from requests. We create three different
components to do that using the \texttt{MakeComponent} function. Below
is the implementation of the component that is used to generate 
the \texttt{addActions}.
\begin{figure}[h]
\begin{lstlisting}
func addActionMakerFunc(val Value) {
    q := val.GetRequest().URL.Query()
    items, ok := q["item"]
    if (ok && len(items) > 0) {
        items = strings.Split(items[0], ",")
    }
    val.SetResult(AddAction{items})
}
var addActionMaker = MakeComponent(addActionMakerFunc) 
\end{lstlisting}
\caption[scale=1.0]{Implementation of the \texttt{addActionMaker}.}
\label{fig:addActionMaker}
\end{figure}

\newpage
\subsection{Plugging it together}
We use different URL paths to perform different actions. We route the 
requests with paths starting with \texttt{/add} to the \texttt{addActionMaker}
and similarly for the other two actions. The output of the action maker
will be connected to the session management component, that is wrapped in
\texttt{ErrorPasser}, so that we don't process invalid requests.
Finally the output from the session manager goes to the \texttt{ErrorSplitter}
which sends all non-error values to to \texttt{JsonWriter} and error
values to \texttt{ErrorWriter}. 

We can share the session manager, the splitter and the writers for all three actions. 
However, this will make it difficult to load balance individual parts
of the networks. Hence, each action maker should be connected to their
own load manager and this to its own splitter and writers. The overall 
design for the add action
is show in diagram of Figure \ref{fig:shoppingDesign}. The \texttt{ErrorPasser} 
is omitted for clarity.
\begin{figure}[h]
\centering
\begin{tikzpicture}[node distance = 2cm, auto]
    % Nodes
    \node [listener] (listener) {/add};
    \node [component, right of=listener, node distance=3cm] (maker) {Add Action Maker};
    \node [component, right of=maker, node distance=3cm] (manager) {Session Manager};
    \node [component, right of=manager, node distance=3cm] (splitter) {Error Splitter};
    \node [writer, right of=splitter, node distance=3cm, yshift=1cm] (writer) {JSON Writer};
    \node [writer, below of=writer] (ewriter) {Error Writer};
    
    % Edges
    \path [line] (listener) -- (maker);
    \path [line] (maker) -- (manager);
    \path [line] (manager) -- (splitter);
    \path [line] (splitter) |- (writer);
    \path [line] (splitter) |- (ewriter);


\end{tikzpicture}
\caption[scale=1.0]{Part of shopping server architecture.}
\label{fig:shoppingDesign}
\end{figure}

We will make the each part of the network into a separate writer as in
the Proxy Server example to be able to use the \texttt{DynamicLoadBalancer}.
The code for making this writer is shown in figure \ref{fig:shoppingWriter}.
Here, we provide action maker and storage for the session manager 
as arguments for the function.

\newpage
\begin{figure}[h]
\begin{lstlisting}
func actionWriter(actionMaker mpserver.Component, 
                  storage mpserver.Storage) mpserver.Writer {
    return func (in <-chan mpserver.Value) {
        // Define session component
        seshComp := mpserver.SessionManagementComponent(
                storage, InitialState, SessionExpiration)
        // Wrap it in an Error Passer
        seshComp = mpserver.ErrorPasser(seshComp)

        // Create channels
        toSeshManager := mpserver.GetChan()
        toSplitter := mpserver.GetChan()
        toWriter := mpserver.GetChan()
        toErrWriter := mpserver.GetChan()

        // Start the components and writers
        go actionMaker(in, toSeshManager)
        go seshComp(toSeshManager, toSplitter)
        go mpserver.ErrorSplitter(
            toSplitter, toWriter, toErrWriter)
        go mpserver.JsonWriter(toWriter)
        mpserver.ErrorWriter(toErrWriter)
    }
}
\end{lstlisting}
\caption[scale=1.0]{Implementation of the writer that represents the whole
pipeline for one action.}
\label{fig:shoppingWriter}
\end{figure}

The benefit of the chosen architecture that resources for the add, remove
and buy actions are allocated independently. That is, if there is lot of 
people adding items to their shopping cart, there can be more instances
of the combined writer for the add action and fewer instances for the
other two actions. The code for running the whole server is shown
in Figure \ref{fig:ShoppingCode}.
\begin{figure}[h]
\begin{lstlisting}
func main() {
    // Create the storage
    storage := mpserver.NewMemStorage()
    // Create writers
    addActionWriter := actionWriter(addActionMaker, storage)
    rmvActionWriter := actionWriter(rmvActionMaker, storage)
    buyActionWriter := actionWriter(buyActionMaker, storage)

    // Wrap them in Load Balancers
    addActionWriter = mpserver.DynamicLoadBalancerWriter(
        addActionWriter, 100, AddTimeout, RemoveTimeout)
    rmvActionWriter = mpserver.DynamicLoadBalancerWriter(
        rmvActionWriter, 20, AddTimeout, RemoveTimeout)
    buyActionWriter = mpserver.DynamicLoadBalancerWriter(
        buyActionWriter, 40, AddTimeout, RemoveTimeout)

    // Make channels
    toAddActionMaker := mpserver.GetChan()
    toRmvActionMaker := mpserver.GetChan()
    toBuyActionMaker := mpserver.GetChan()

    // Start the load balanced writers
    go addActionWriter(toAddActionMaker)
    go rmvActionWriter(toRmvActionMaker)
    go buyActionWriter(toBuyActionMaker)
    go mpserver.StorageCleaner(storage, nil, SessionExpiration)

    // Start the server
    mux := http.NewServeMux()
    mpserver.Listen(mux, "/add", toAddActionMaker)
    mpserver.Listen(mux, "/remove", toRmvActionMaker)
    mpserver.Listen(mux, "/buy", toBuyActionMaker)
    log.Println("Listening on port 3000...")
    http.ListenAndServe(":3000", mux)
}
\end{lstlisting}
\caption[scale=1.0]{Implementation of the Shopping Server.}
\label{fig:ShoppingCode}
\end{figure}



